## Тестовое задание TradeLink

Задачи можно выполнять на JavaScript (в среде Node.js)
Использование Typescript приветствуется, сам проект с решениями должен устанавливаться обычным `npm install` или `yarn`,
в README.md укажите версии node, npm и инструкцию по запуску.
Написание тестов приветствуется.

Нужно выполнить все задачи. При решении каждой задачи необходимо привести 
максимально возможное, асимптотически оптимальное по памяти и времени решение. 
В задачах раздела `B` в большей степени оценивается дизайн кода и реализация.

Во всех случаях подразумевающих ввод/вывод, предполагается stdin/stdout. 
При решении задач нельзя пользоваться дополнительными библиотеками, 
только средствами языка и стандартной библиотекой.
Для тестов разрешается использовать любую библиотеку.

### A1. Скобки

На вход подается строка состоящая из различных символов в пределах ASCII,
скобками считаются символы `()[]{}`, все что не является скобками, 
считается некоторыми корректными частями выражения. 
Строка является корректным выражением, если все скобки в нем корректно закрываются, 
то есть каждая закрывающая скобка закрывает последнюю открытую скобку исключительно своего типа,
иначе это некорректно, открывающим скобкам `(, [, {` соответствуют закрывающие `), ], }`.
Например выражение `(123[abc]45)` является корректным, а выражение `([abc)]` – нет.
Необходимо на вывод вывести `Correct`, если строка является корректным выражением и `Incorrect`, 
если не является.

#### Пример
Ввод
```
([abc])
```
Вывод
```
Correct
```

### A2. (Не) Фибоначчи

Числа Фибоначчи (https://ru.wikipedia.org/wiki/Числа_Фибоначчи) образуют 
неубывающую последовательность:

0, 1, 1, 2, 3, 5, 8, 13, 21, ... 

Числами не Фибоначчи будем называть последовательность чисел, 
которые не входят в последовательность чисел Фибоначчи: 

4, 6, 7, 9, 10, 11, 12, 14, ...

В решении должен присутствовать **бесконечный генератор** последовательности чисел не-Фибоначчи.
Для возможности проверки тестами, требуется вывести ограниченное количество N первых чисел последовательности.
На вход подается число N, означающее количество чисел, которое необходимо вывести на вывод,
каждое в отдельной строке. 
N может быть достаточно большим, чтобы формула вычисления N-го числа Фибоначчи не могла быть применима и эффективна.

#### Пример
Ввод
```
5
```
Вывод
```
4
6
7
9
10
```

### B1. LRU

Кэш с политикой Least Recently Used используется для отбрасывания из памяти элементов, 
которые по логическому времени использовались в достаточной степени давно,
назовем это счетчиком давности.
Запрос некоторого ключа (равно как и добавление нового) 
обнуляет счетчик давности этого ключа и увеличивает на 1 счетчик давности 
всех существующих ключей в кэше, кроме запрошенного.
Те ключи, чей счетчик давности больше чем max_size (задается параметром для кэша) – 
выбрасываются из кэша.
Необходимо реализовать класс для LRU кэша, класс должен уметь принимать 
параметр максимального размера кэша при инициализации, 
должен предоставлять проксирующий метод, 
который принимает на вход ключ, функцию и её аргументы.
Если значение по ключу есть в кэше, то метод не вызывает функцию, а возвращает значение из кэша, 
если такой ключ отсутствует в кэше, то выполняется функция с переданными аргументами,
её результат записывается в кэш и возвращается.
При решении этой задачи нельзя пользоваться готовыми структурами данных, 
которые предоставляет язык, кроме тривиальных, проще говоря – здесь запрещается 
использовать стандартную библиотеку, то есть какие-либо require кроме собственного кода. 
Дополнительно для nodejs: нельзя пользоваться свойством insertion порядка ключей в Map (А в Object спецификацией и не гарантируется)

### B2. Счетчик

Счетчик количества запросов используется для определения RPS (Requests Per Second), например.
В общем случае хотелось бы считать что-то иное количественное за заданный промежуток времени, 
например вес запросов за минуту, которые поступают в API, если запросы разной сложности.
Важно заметить, что необходимый промежуток времени постоянно сдвигается, 
и просто считать запросы за какой-то предыдущий фиксированный промежуток – не подходит.
Здесь необходимо реализовать обобщенный класс, инициализирующийся параметром промежутка времени, 
за который ведется подсчет, который имеет метод hit, принимающий аргументом значение, 
на которое увеличивается счетчик, и метод count, возвращающий текущее значение счетчика.
Запросов может быть очень много, поэтому здесь нужно выбрать оптимальное 
соотношение между точностью и ресурсами, которые будет потреблять такая структура, 
скажем, если счетчик считает за минуту (60 секунд), 
допустима погрешность/отставание в районе 3 секунд (то есть 1/20 интервала). 

### C. Разделяй и властвуй

На вход подается число `N`, затем подается `N` слов состоящих из латинских символов.
Эти слова образуют известный нам словарь некоторого языка.
Далее на вход подается число `K`, затем подается `K` строк, состоящих из латинских символов.
Необходимо проверить, является ли строка конкатенацией ровно двух известных слов.
На вывод на каждую строку возвращается количество всех возможных конкатенаций, 
а затем сами варианты разделения в любом порядке через пробел, в месте разделения ставится двоеточие.

Здесь предполагается, что `K` достаточно большое, 
чтобы требовать от алгоритма максимально возможной скорости выполнения, 
ценой, возможно, дополнительной памяти. `S` и сами строки в задаче могли бы представлять словарь какого-нибудь реального популярного языка.

Дополнительно, для своего решения задачи оцените сложность в терминах O-большое, где дополнительно через `S` обозначается средняя длина строки-запроса, а через `L` обозначается средняя длина строки-словаря. Например, O(N^2 * L^2 * KS).

#### Пример
Ввод
```
5
abcd
cdef
ab
ef
ffff
2
abcdef
ffff
```
Вывод
```
2 abcd:ef ab:cdef
0
```
